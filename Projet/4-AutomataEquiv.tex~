\section{Reflecting automata equivalences in the logic}

It is well know that the models of APW, NPW and NBW automata are equivalent,
in the sens that a language is recognized by an APW automaton iff its recognized by 
a NPW (reps. NBW) automaton. This result is usually shown  by exibiting  automata transformations that converts an automaton  of a model to an automaton in the other models, by preserving the language. 
In this section, we recall these automata transformations (at least the ones 
that will be used for the proof of completeness), and show that the encoding
of an automaton and the one obtained by the transformation are provably equivalent. 

\subsection{From APW to NPW automata}
We recall the construction that transforms an APW automaton $\C{A}$ into an NPW
$\C{P}$ such that  $\C{L}(\C{P})=\C{L}(\C{A})$. In a second step, we show that the sequent $\interp{\C{P}}\vdash \interp{\C{A}}$ in provable \muLKnext.

\subsubsection{Automata transformation $\dots$}
 We show how to transform an APW into a  NPW with the same language. This operation is called \textit{non-determinization}. 
The construction we present corresponds to the standard construction of non-determinization for alternating automata over trees as presented in \cite{Thomas:1997}, but specialized for automata over words.

The key ingredient to non-determinize  APW automata is to simplify their runs. In a run  $\tau$ of an APW automaton, two nodes at the same level of the tree $\tau$, labelled with the same state, may have different sets of successors. For example, in the following run of the automaton $\C{A}_0$ of Example~\ref{ex:AlternatingAutomaton} over the word $a^\omega$, the green node and the red node, which are both at level $2$ and which are both labelled $q$, have different successors. 
\begin{center}
\scalebox{.75}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=.8cm, semithick]
\tikzstyle{run} = [circle, minimum width= 3pt, fill, inner sep=0pt] 
  \node (p0)  at (0,0)  {$p$};
  \node(q1)       at (0,-1)      {$q$};
  \node(p1)      at (-1,-1)      {$p$};
  \node(q20)  at (0,-2)      {\textcolor{red}{$q$}};
  \node(q21)  at (-1,-2)      {\textcolor{green}{$q$}};
  \node(p2)  at (-2,-2)      {$p$};
  \node(q30)  at (0,-3)      {$q$};
  \node(q31)  at (-1,-3)      {$p$};
 \node(q32)  at (-2,-3)      {$q$};
  \node(p3)  at (-3,-3)      {$p$};
  \node[](dots)  at (0,-3.5)      {$\vdots$};
  \node[](dots)  at (-1,-3.5)      {$\vdots$};
  \node[](dots)  at (-2,-3.5)      {$\vdots$};
  \node[](dots)  at (-3,-3.5)      {$\vdots$};
 \path (p0) edge   node {} (p1)
       (p0) edge   node {} (q1)
       (p1) edge   node {} (p2)
       (p1) edge   node {} (q21)
       (q1) edge   node {} (q20)
       (q20) edge   node {} (q30)
  (q21) edge   node {} (q31)
 (p2) edge   node {} (p3)
       (p2) edge   node {} (q32)
;
\end{tikzpicture}}
\end{center}
We call \textit{Non-uniform} this kind of runs. On the contrary, when a run is such that: if two nodes are at the same level and have the
 same labels then they have the same set of successors, they are called \textit{uniform}.
We fix in the rest of this subsection an APW automaton $\C{A}=(\Sigma, Q, \Delta, q_I, c)$.
\begin{definition}[Uniform runs]
Let $\tau=(T,l)$ be a run of $\C{A}$ over a word $u$. The run $\tau$ is called \defname{uniform}
iff $\forall n\in\omega$, if $v, w$ are two nodes at level $n$ such that $l(v)=l(w)$ and such that $\{v_i\}_{1 \leq i\leq k}$ and $\{w_i\}_{1 \leq i\leq m}$
 are the sons of $v$ and $w$ respectively, then $\{l(v_i)\}_{1 \leq i\leq k}=\{l(w_i)\}_{1 \leq i\leq m}$.  
\end{definition}

By using game theoretical techniques, namely the determinacy of parity games, one can show that, when computing the language of an APW automaton, uniform runs are sufficient.  

\begin{theorem}
 For evry word $u$, $u\in \C{L}(A)$  iff there is a valid uniform run of $\C{A}$ over $u$. 
\end{theorem}

The main characteristic of uniform runs is that they can be seen as sequences of functions, each function of such a sequence corresponds to a level, and maps every state of this level to its successors.
For example, the run $\tau_0$ of Example~\ref{ex:runsAlternatingAutomaton} can be seen as a sequence $f_0f_1f_2\dots$ where $f_0(p)=\{p,q\}$, $f_1(p)=\{p,q\}, f_1(q)=q$, $f_2(p)=\{p,q\}, f_2(q)=q, \dots$. It is 
clear that non-uniform runs cannot be described in this way. 
These functions are called \defname{choice functions}, we define them formally as follows: 

\begin{definition}
A \defname{choice function} is a function $\sigma: Q\rightarrow 2^Q$. The set of choice functions is denoted $\C{S}$.
\end{definition}  

\begin{remark}
The set $\C{S}$ is finite.
\end{remark}

Let us consider the following new alphabet:

\begin{definition}\label{def:AuxAlphabet} The auxiliary alphabet of $\C{A}$ is 
 the alphabet $\Sigma^{aux}=\{(a,\sigma)\in\Sigma\times \C{S}\ \vert \ (p,a,\sigma(p))\}$. 
\end{definition}
From a $\Sigma^{aux}$-word $U$, one can extract two sequences: the first one is a $\Sigma$-word $u$ obtained by projection on the first component, and the second, obtained by projection on the second component, is
a sequence of choice functions. This latter sequence describes, thanks to the side condition in the definition of $\Sigma^{aux}$, a run of $\C{A}$ over $u$, as we shall see in the following.


\begin{definition}\label{RunAssociatedWord}
Let $U=((a_i,\sigma_i))_{i\in\omega}$ be a $\Sigma^{aux}$-word. 
The \defname{run associated} to $U$ is the $Q$-labelled tree $(T,l)$ satisfying the following conditions:
\begin{itemize}
\item $l(r)=q_I$ where $r$ is the root of $T$.
\item Let $v$ be a node of $T$ at level $n$ and $\{v_i\}_{1\leq i\leq k}$ be the sons of $v$. If $q=l(v)$  then
 $\{l(v_i)\}_{1\leq i\leq k}=\sigma_n(q)$.
\end{itemize}
\end{definition}  

\begin{proposition}
Let  $U=((a_i,\sigma_i))_{i\in\omega}$ be a $\Sigma^{aux}$-word and let $u=\{a_i\}_{i\in\omega}$. The run associated to $U$ is a run of $\C{A}$ over $u$.
\end{proposition}

A  $\Sigma^{aux}$-word contains then, at the same time, a $\Sigma$-word and all the necessary informations to its execution. We see here all the interest of using uniform runs instead of arbitrary runs:
 we went from runs having a tree structure to runs with a structure of words, that we were able to synchronize with $\Sigma$-words.   
  

\begin{definition}\label{def:AuxLanguage}
The language $L\subseteq (\Sigma^{aux})^\omega$ is the \defname{auxiliary language} of $\C{A}$ if $\forall U\in L,$ the run associated to $U$ is valid (wrt. the validity condition of $\C{A}$). 
We denoted it by $\C{L}^{aux}(\C{A})$.
\end{definition}


The idea of the non-determinization is to exhibit a DPW automaton recognizing the auxiliary language of $\C{A}$. Intuitively, this is possible since all the information of alternation is explicit in 
the $\Sigma^{aux}$ words, hence we do not need an alternating automaton to recognize it. Once this is done, it suffices to erase the choice functions from the transition structure of this automaton, 
which results in a NPW automaton recognizing the language of $\C{A}$.
\begin{proposition}\label{NPW=APW}
For very APW  we can construct effectively  a NPW recognizing the same language.
\end{proposition}

\begin{proof}[proof sketch]
Let $\C{A}=(\Sigma, Q, \Delta, q_I, c)$ be an APW. We construt a NPW recognizing the language of $\C{A}$ in two steps.
\begin{enumerate}
\item[I.] Construct a $DPW$ automaton  $\C{D}=(\Sigma^{aux}, Q^d, q^d_I, \Delta^d, c^d)$ recognizing  $\C{L}^{aux}(\C{A})$.
\item [II.] Drop the choice functions from the transitions of  $\C{D}$ to get a $NPW$ automaton $\C{P}$ recognizing $\C{L}(\C{A})$. That is, 
$\C{P}=(\Sigma, Q^d, q^d_I, \Delta', c^d)$, where $\Delta'$ is defined by: $$\Delta'=\{(d, a, d') \ \vert \ \exists \sigma, (d, (a,\sigma), d')\in\Delta^d\}$$
\end{enumerate}
The details of the step $I$ can be found in \cite{TechReport}, 
be they are not needed for the proof of completeness.
\end{proof}
\subsubsection{$\dots$ in the logic}
Let  $\C{A}$ be an APW automaton and $\C{P}$ be the NPW obtained in the proof 
of Proposition~\ref{NPW=APW}. In this section we show that 
$\interp{\C{P}}\vdash \interp{\C{A}}$ has a proof in \muLKnext. For that purpose, we exibit an easy proof of this sequent in \muLKonext, which gives us a \muLKnext proof by Proposition~\ref{}.
We will use the notations of the previous section. Namely, the auxiliary alphabet of $\C{A}$ is denotd $\Sigma^{aux}$, the DPW automaton $\C{D}$ constructed at step $I$ of the proof of Proposition~\ref{NPW=APW} is $\C{D}=(\Sigma^{aux}, Q^d, q^d_I, \Delta^d, c^d)$ and $\C{P}=(\Sigma, Q^d, q^d_I, \Delta', c^d)$.
Since $\C{P}$ and $\C{D}$ have the same set of states, to avoid any confusion, we go back to the original notation and write explicitely the automaton in the encoding of a state.

Since $q_I$ and $q_I^d$ are the initial states of $\C{A}$ and $\C{P}$ respectively,  one has that $\interp{\C{A}}=\interp{q_I}^\emptyset$ and $\interp{\C{P}}=\interp{q_I^d}^\emptyset$, hence our goal is to show that $\interp{q_I^d}^\emptyset\vdash\interp{q_I}^\emptyset$ has an easy proof in \muLKonext. To do so, we need to  generalise this statement, and look for proofs of sequents having the form $\interp{d}^\Theta\vdash\interp{q}^\Upsilon$, where 
$d$ and  $\Theta$ are a state and an environment for $\C{P}$; $q$ and  $\Upsilon$ are a sate and an environment for  $\C{A}$.

\begin{proposition}\label{prop:flecheAPW=NPW}
Let $q\in Q$ and $d\in Q'$. The following rule, denoted $(\rightarrow)$, is derivable in \muLKonext:
 $$\begin{prooftree}
  \Hypo{\{ \{\interp{d'}^{\Theta,d}\vdash \interp{q'}^{\Upsilon,q}\}_{q'\in\sigma(q)} \}_{(a,\sigma)\in\Sigma^{aux}, (d,(a,\sigma),d')\in\Delta^d }}
  \Infer{1}[\scriptsize{$(\rightarrow)$}]{{\interp{d}^\Theta}\vdash{\interp{q}^\Upsilon}}
  \end{prooftree}
$$
Where $\Sigma^{aux}$ is the auxiliary alphabet of $\C{A}$ (Definition~\ref{def:AuxAlphabet})
\end{proposition}


\begin{proof}
By Proposition~\ref{propo:NoCaseAnalysis}, one has:
$$
\begin{array}{lll}
 \interp{d}^\Theta&\rightarrow& \underset{a\in\Sigma, (d,a,d')\in\Delta'}{\bigvee} [a]\wedge\odot\interp{d'}^{\Theta,d}\\
&=& \underset{(a,\sigma)\in\Sigma^{aux},  (d,(a,\sigma),d')\in\Delta^d}{\bigvee} [a]\wedge\odot\interp{d'}^{\Theta,d}
\end{array}$$
We can then derive the following:
  $$\begin{prooftree}
   \Hypo{ \{  [a], \odot\interp{d'}^{\Theta,d}\vdash {\interp{q}^\Upsilon}\}_{(a,\sigma)\in\Sigma^{aux}, (d,(a,\sigma),d')\in\Delta^d}}
  \Infer[rulestyle=double]{1}[\rdisjl,\rconjl]{ \underset{(a,\sigma)\in\Sigma^{aux}, (d,(a,\sigma),d')\in\Delta^d}{\bigvee} [a]\wedge\odot\interp{d'}^{\Theta,d}\vdash {\interp{q}^\Upsilon}}
  \Infer{1}[\rsigmal]{\interp{d}^\Theta\vdash{\interp{q}^\Upsilon}}
  \end{prooftree}
$$
One has to justify now, for every $(a,\sigma)\in\Sigma^{aux}$ and $(d,(a,\sigma),d')\in\Delta^d$ the premisse $[a], \odot\interp{d'}^{\Theta,d}\vdash {\interp{q}^\Upsilon}$.
One has:
$$
\begin{array}{lll}
 \interp{q}^\Upsilon&\rightarrow& \underset{a\in\Sigma, (q,a,E)\in\Delta}{\bigvee} [a]\wedge\underset{q'\in E}{\bigwedge}\odot\interp{q'}^{\Upsilon,q}
\end{array}$$
Since $(a,\sigma)\in\Sigma^{aux}$, one has that $(q,a, \sigma(q))\in \Delta$. We can the derive the following:
  $$\begin{prooftree}
   \Hypo{ \{  [a], \odot\interp{d'}^{\Theta,d}\vdash \odot\interp{q'}^{\Upsilon,q}\}_{q'\in\sigma(q)}}
  \Infer{0}[\rax]{[a] \vdash [a]}
  \Infer{1}[\rweakl]{[a], \odot\interp{d'}^{\Theta,d}\vdash [a]}
  \Infer[rulestyle=double]{2}[\rconjr]{[a],\odot\interp{d'}^{\Theta,d}\vdash [a]\wedge\underset{q'\in \sigma(q)}{\bigwedge}\odot\interp{q'}^{\Upsilon,q}}
  \Infer[rulestyle=double]{1}[\rsigmar, \rdisjr,\rweakr]{ [a], \odot\interp{d'}^{\Theta,d}\vdash {\interp{q}^\Upsilon}}
  \end{prooftree}
$$
We end up by applying a $\rnext$ to every open premisse  to get the desired derivation.
\end{proof}

\begin{theorem}
One can construct a \muLKnext proof of  $\interp{\C{P}}\vdash \interp{\C{A}}$.
\end{theorem}

\begin{proof}
Recall that $\interp{\C{A}}=\interp{q_I}^\emptyset$ and $\interp{\C{P}}=\interp{q_I^d}^\emptyset$. 
Let $\pi$ be the derivation obtained by applying coinductively the derivation $(\rightarrow)$ of Proposition~\ref{prop:flecheAPW=NPW}.
It is easy to see that $\pi$ is a regular tree, hence $\pi$ is a  \muLKonext pre-proof.

We show first that $\phi$ is a  \muLKonext proof, that is to say, it satisfies the validity condition. Let $\beta=s_0\dots s_1\dots$
be a branch of $\pi$, where $s_i$ are the conclusions of the derivations $\rightarrow$. One has that $s_0=\interp{q_I^d}^\emptyset\vdash\interp{q_I}^\emptyset$
and for all $i$, $s_i=\interp{d_i}^{\Theta_i}\vdash\interp{q_i}^{\Upsilon_i}$ and where $\exists a_i,\sigma_i$  such that $(d_i,(a_i,\sigma_i),d_{i+1})\in\Delta^d$.
Let $U$ be the $\Sigma^{aux}$-word defined by $U=((a_0,\sigma_0))_{i\in\omega}$. Let $\pi(U)$ be the smallest subtree of $\pi$ satisfying the following:
\begin{itemize}
\item $\interp{q_I^d}^\emptyset\vdash\interp{q_I}^\emptyset \in \pi(U)$.
\item If $\interp{d_i}^{\Theta_i}\vdash\interp{q}^{\Upsilon}\in\pi(U)$ then $\interp{d_{i+1}}^{\Theta_{i+1}}\vdash\interp{q'}^{\Upsilon,q}\in\pi(U)$ for all $q'\in\sigma_i(q)$. 
\end{itemize}
Constructing $\pi(U)$ amounts to chose for every application  in $\pi$ of the derivation $(\rightarrow)$ of the form:
  $$\begin{prooftree}
  \Hypo{\{ \{\interp{d'}^{\Theta,d}\vdash \interp{q'}^{\Upsilon,q}\}_{q'\in\sigma(q)} \}_{(a,\sigma)\in\Sigma^{aux}, (d,(a,\sigma),d')\in\Delta^d }}
  \Infer[rulestyle=double]{1}[\scriptsize{$(\rightarrow)$}]{{\interp{d_i}^{\Theta_i}}\vdash{\interp{q}^\Upsilon}}
  \end{prooftree}
$$
the premisses corresponding to $(a,\sigma)=(a_i,\sigma_i)$. 
Notice that the branch $\beta$ is a branch of $\pi(U)$ and that all the branches of $\pi(U)$ have the same left hand side thread, which is also the left hand side thread of $\beta$. 
The derivation $\pi(U)$ induces two runs: the left-hand side thread induces a run of $\C{D}$ over $U$, and if we collect all the right hand side threads, we get a run of $\C{A}$.
 We make this observation more precise in the following.

It is easy to see that $\rho=d_0d_1\dots$ is the run of $\C{D}$ over $U$. 
Let $R$ be the smallest tree satisfying:
\begin{itemize}
\item The root of $R$ is labelled $q_I$.
\item If a node $n$ is at the i-th level, then for every $\interp{d_{i+1}}^{\Theta_{i+1}}\vdash\interp{q'}^{\Upsilon,q}\in\pi(U)$, the node $n$ has a son labelled $q'$.  
\end{itemize} 
It is easy to see that the tree $R$ is the run of $\C{A}$ associated to the word $U$ (Definition~\ref{RunAssociatedWord}). Notice that $q_0q_1\dots$ is a branch of $R$. 
There is two possible cases:
\begin{itemize}
\item If $U$ is not in the auxiliary language of $\C{A}$, then the run $\rho$ of $\C{D}$ is not valid. Hence $\rho$, seen as a run of $\C{P}$ is also not valid, since $\C{P}$ and $\C{D}$
have the same set of states and the same priority function. By Proposition~\ref{AdequacyThreadsRuns}, the thread $t=\interp{d_0}^{\Theta_0}\dots\interp{d_1}^{\Theta_1}\dots$ of $\interp{\C{P}}$ is a $\mu$-thread, hence the branch $\beta$ is valid. 
\item If $U$ is in the auxiliary language, then the run $R$ is valid. In particular, the branch $q_0q_1\dots$ is valid. By  Proposition~\ref{AdequacyThreadsRuns}, the thread $\interp{q_0}^{\Upsilon_0}\dots\interp{q_1}^{\Upsilon_1}\dots$ is a $\nu$-thread, hence the branch $\beta$ is valid.
\end{itemize}

Finally, notice that all the applications of rules $\rsigmar$ and $\rsigmal$ in $\pi$ are easy, hence $\pi$ is an easy \muLKonext proof. By Proposition~\ref{}, we can transform $\pi$ into a \muLKnext proof of the sequent  $\interp{\C{P}}\vdash \interp{\C{A}}$, which concludes the proof of the theorem. 
 \end{proof}

\subsection{From NPW to NBW automata}

We recall the construction that transforms an NPW automaton $\C{P}$ into an NBW
$\C{B}$ such that  $\C{L}(\C{B})=\C{L}(\C{P})$. In a second step, we show that the sequent $\interp{\C{B}}\vdash \interp{\C{P}}$ in provable \muLKnext.

\subsubsection{Automata transformation $\dots$}
 In this section, we show how to transform an NPW into a  NBW with the same language.
\begin{proposition}\label{prop:NPW=NBW}
For very NPW  we can construct effectively  a NBW recognizing the same language, and conversly.  
\end{proposition}

\begin{proof}
Let $\C{P}=(\Sigma, Q, \Delta, q_I, c)$ be a NPW automaton and let $Q_{ev}=\{p \in Q \ \vert \ c(p) \text{ is even}\}$. The idea is to create for every 
even state $p$, a copy of the automaton $\C{P}$ where the state $p$ will be accepting and where all the states with smaller priority will be dropped. We keep also a copy of 
 $\C{P}$ where no state is accepted. A run will stay in this copy for some time and will chose one of the copies where an even state is accepting. Formally, 
let $\C{B}=(\Sigma, Q_\bot\cup\underset{p\in Q_{ev}}{\bigcup}Q_p, (q_I,\bot), \Delta_{\bot}\cup\Delta_t\cup\underset{p\in Q_{ev}}{\bigcup}\Delta_p, F)$ be the NBW automaton where:
\begin{itemize}
\item $\forall i\in\{\bot\}\cup Q_{ev},\quad Q_i=\{(q,i)\ \vert \ q\in Q\}$
\item $\Delta_{\bot}=\{ ((q,\bot),(r,\bot))\ \vert \ (q,r) \in \Delta\}$
\item $\Delta_{t}=\{ ((q,\bot),(r,r))\ \vert \ (q,r) \in \Delta \text{ and } r\in Q_{ev}\}$
\item $\forall p\in Q_{ev}, \Delta_{p}=\{ ((q,p),(r,p))\ \vert \ (q,r) \in \Delta \text{ and } c(q),c(r)\geq c(p)\}$
\end{itemize}
The states $Q_\bot$ and the relation $\Delta_\bot$ correspond to the copy of $\C{P}$ without any accepting state, and for every $p\in Q_{ev}$, the states $Q_p$ and the relation $\Delta_p$ correspond to the copy
 where $p$ is accepting. The relatin $\Delta_t$ serves as a transition between the non-accepting copy and the other copies.
It is not difficult to show that $\C{L}(\C{P})=\C{L}(\C{B})$.
\end{proof}

\subsubsection{$\dots$ in the logic}

Let $\C{P}=(Q,q_I,\Delta,c)$ be an NPW automaton. Our goal in this section is to prove that there is a NBW automaton $\C{B}$ recognizing the same language and such that there is a
 translatable \muLKonext proof
of $[\C{B}]_\epsilon\vdash[\C{P}]_\epsilon$. We have shown in Proposition~\ref{prop:NPW=NBW} how to transfom a NPW automaton into a NBW one. We use the notations of the proof of this proposition.


\begin{proposition}\label{prop:flecheNPW=NBW}
Let $q\in Q$. The following derivations, denoted $(\hookrightarrow)$, are derivable in \muLKonext:
 $$\begin{prooftree}
  \Hypo{\{\interp{(q',\bot)}^{(q,\bot),\Theta}\vdash \interp{q'}^{\Upsilon,q} \}_{(q,a,q')\in\Delta}}
  \Hypo{\{\interp{(p,p)}^{(q,\bot),\Theta}\vdash \interp{p}^{\Upsilon,q}\}_{(q,a,p)\in\Delta, p\in Q_{ev}}}
  \Infer[rulestyle=double]{2}[\scriptsize{$(\hookrightarrow)$}]{{\interp{(q,\bot)}^\Theta}\vdash{\interp{q}^\Upsilon}}
  \end{prooftree}
$$
If $r\in Q_{ev}$ and $c(r)\leq c(q)$:
 $$\begin{prooftree}
  \Hypo{\{\interp{(q',r)}^{(q,r),\Theta}\vdash \interp{q'}^{\Upsilon,q} \}_{(q,a,q')\in\Delta, c(q')\geq c(r)}}
  \Infer[rulestyle=double]{1}[\scriptsize{$(\hookrightarrow)$}]{{\interp{(q,r)}^\Theta}\vdash{\interp{q}^\Upsilon}}
  \end{prooftree}
$$
\end{proposition}

\begin{proof}
One has: 
$$
 \interp{(q,\bot)}^\Theta \rightarrow \underset{(q,a,q')\in\Delta}{\bigvee} [a]\wedge\interp{(q',\bot)}^{(q,\bot),\Theta} \vee \underset{(q,a,p)\in\Delta, p\in Q_{ev}}{\bigvee} 
[a]\wedge\interp{(p,p)}^{(q,\bot),\Theta}
$$
hence, the following is derivable in \muLKonext:
 $$\begin{prooftree}
  \Hypo{\{[a], \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash \interp{q}^{\Upsilon} \}_{(q,a,q')\in\Delta}}
  \Hypo{\{[a], \interp{(p,p)}^{(q,\bot),\Theta}\vdash \interp{q}^{\Upsilon}\}_{(q,a,p)\in\Delta, p\in Q_{ev}}}
  \Infer[rulestyle=double]{2}[\rdisjl, \rconjl]{\underset{(q,a,q')\in\Delta}{\bigvee} [a]\wedge\interp{(q',\bot)}^{(q,\bot),\Theta} \vee \underset{(q,a,p)\in\Delta, p\in Q_{ev}}{\bigvee} 
[a]\wedge\interp{(p,p)}^{(q,\bot),\Theta}\vdash{\interp{q}^\Upsilon}}
  \Infer{1}[\rsigmal]{{\interp{(q,\bot)}^\Theta}\vdash{\interp{q}^\Upsilon}}
  \end{prooftree}
$$
One has that:
$$
 \interp{q}^\Upsilon \rightarrow \underset{(q,a,q')\in\Delta}{\bigvee} [a]\wedge\interp{q'}^{\Upsilon,q} 
$$
To justify the premisses of the form $[a], \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash \interp{q}^{\Upsilon}$ in the previous derivation, we do the following:
 $$\begin{prooftree}
  \Infer{0}[\rax]{[a], \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash [a] }
  \Hypo{ \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash\interp{q'}^{\Upsilon,q} }
 \Infer{1}[\rweakl]{[a], \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash\interp{q'}^{\Upsilon,q} }
  \Infer{2}[\rconjr]{[a], \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash [a]\wedge\interp{q'}^{\Upsilon,q} }
  \Infer[rulestyle=double]{1}[\rsigmar, \rdisjr, \rweakr]{[a], \interp{(q',\bot)}^{(q,\bot),\Theta}\vdash \interp{q}^{\Upsilon}}
  \end{prooftree}
$$
The other premisses are justified in exactly the same way.


To derive $(\hookrightarrow)$ the case where $r\in Q_{ev}$, it suffices to see that, due to the shape of the transition relation of $\C{B}$, one has:
$$
 \interp{(q,r)}^\Theta \rightarrow \underset{(q,a,q')\in\Delta, c(q')\geq c(r)}{\bigvee} [a]\wedge\interp{(q', r)}^{(q,\bot),\Theta} 
$$  
\end{proof}

\begin{theorem}
The sequent $[\C{B}]_\epsilon\vdash[\C{P}]_\epsilon$ has a translatable \muLKonext proof.
\end{theorem}

\begin{proof}
One has $[\C{P}]_\epsilon=\interp{q_I}^\emptyset$ and $[\C{B}]_\epsilon=\interp{(q_I,\bot)}^\emptyset$. 
Let $\pi$ be the derivation obtained by applying coinductively the derivation $(\hookrightarrow)$ of Proposition~\ref{prop:flecheNPW=NBW}.
It is easy to see that $\pi$ is a regular tree, hence $\pi$ is a  \muLKonext pre-proof.

We show first that $\phi$ is a  \muLKonext proof, that is to say, it satisfies the valididty condition. Let $\beta=s_0\dots s_1\dots$
be a branch of $\pi$, where $s_i$ are the conclusions of the derivations $\hookrightarrow$. One has that $s_0=\interp{(q_I,\bot)}^\emptyset\vdash\interp{q_I}^\emptyset$
and for all $i$, $s_i=\interp{(q_i,r_i)}^{\Theta_i}\vdash\interp{q_i}^{\Upsilon_i}$ where $\exists a_i$  such that $(q_i,a_i,q_{i+1})\in\Delta$.
Let $u$ be the $\Sigma$-word defined by $u=a_0a_1\dots$. The sequence $\rho_{\C{B}}=(q_O,r_0)(q_1,r_1)\dots$ is a run of $\C{B}$ over $u$ and 
 $\rho_{\C{P}}=q_Oq_1\dots$ is a run of $\C{P}$ over $u$.
There is two possible cases:
\begin{itemize}
\item The run $\rho_{\C{B}}$ is not valid, then by Proposition~\ref{AdequacyThreadsRuns} the left hand side thread $t_l=\interp{(q_0,r_0)}^{\Theta_0}\dots\interp{(q_1,r_1)}^{\Theta_1}\dots$ of $\beta$ is a $\mu$-thread, hence $\beta$ is a valid branch.
\item The run $\rho_{\C{B}}$ is valid, this means that there is $r\in Q_{ev}$ and $j\in \omega$ such that $\forall i\geq j$ one has $r_i=r$ and $c(q_i)\geq c(r)$ and $q_i=r$ infnitly many times.
Hence the run $\rho_{\C{P}}$ is also valid. By Proposition~\ref{AdequacyThreadsRuns}, the right hand side thread $t_r=\interp{q_0}^{\Upsilon_0}\dots\interp{q_1}^{\Upsilon_1}\dots$ of $\beta$ is a $\nu$-thread, hence $\beta$ is a valid branch.
\end{itemize}

To show that $\pi$ is translatable, it suffices to observe that it is an easy derivation: whenever we applied a $\sigma_l$ (resp. a $\sigma_r$) rule in the $\hookrightarrow$ derivation, the fixed point formula was alone in the left (resp. right) environment.
\end{proof}


%\subsection{From NBW to DBW automata}


%\subsubsection{Last link in chain}
