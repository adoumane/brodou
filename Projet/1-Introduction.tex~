

\section{Introduction}


%\paragraph{Completeness problem and constructiveness}
The linear-time \mucalculus \cite{vardi88} is a temporal logic that  extends Pnueli's \textit{Linear Temporal Logic} (LTL) \cite{pnueli86}
 with least and greatest fixed points. This increases considerably 
its expressive power while keeping  the decidability properties of LTL, which makes it a very suitable logic for verification.
The linear-time \mucalculus has infinite words as models, thus
it can be used to express trace properties of reactive systems.
%
There exist, among others, two approaches to verification using temporal logics  \cite{WalukThese}. The first one,  called  “model theoretic", describes both the system $S$ and the property $P$ to check as formulas $\phi_S$ and $\phi_P$; then verifying whether $S$ satisfies $P$ is reduced to checking the validity of the formula $\phi_S\rightarrow\phi_P$. 
The other approach, called  “proof theoretic" reduces the verification problem
to the provability of the formula  $\phi_S\rightarrow\phi_P$. 
%
The advantage of the second approach is that it gives, besides the boolean answer to the verification problem, a \emph{certificate} that supports the decision of the verification tool,
which is the proof of the formula $\phi_S\rightarrow\phi_P$. 
%
To make this approach work with the linear-time \mucalculus, two conditions should be satisfied: the first is the existence of a sound and complete deductive system for the linear-time \mucalculus; the second is the existence of algorithms that produce proofs for valid formulas%and counter examples for non-valid ones
. The first condition is satisfied, since the linear-time \mucalculus enjoys a deductive system, that we call \muLK, which is the restriction of Kozen's axiomatization for the modal \mucalculus to the linear time. This system was proved to be sound and complete by Kaivola (\cite{kaivola95}). But the second condition is not really met, since the only existing algorithm is the naive one, that enumerates all \muLK proofs.
 
A proof of completeness is a mathematical argument
showing that every valid formula is provable, but it is not always possible to extract from such argument an algorithm that produces proofs for valid formulas. Indeed,  completeness proofs may involve complex,
non-constructive arguments yielding no  method for actually constructing a proof. On the contrary, a constructive proof
of completeness, specifying a proof search method,
readily provides a “realistic”  algorithm. 

None of the existing proofs of completeness for the \mucalculus \wrt Kozen's axiomatization (\cite{kaivola95}, \cite{Waluk95}) is constructive in this sense. All the attempts to get constructive proofs were either partial (Kozen provided a constructive completeness proof for the fragment of
 \emph{aconjunctive} formulas \cite{Kozen83}); or fall out of Kozen's axiomatization. Indeed, in his first completeness result \cite{Waluk93}, Walukiewicz
had to modify Kozen's axiomatization to get a constructive proof  for an ad-hoc proof system.

In this paper, we provide a constructive proof for the full linear-time \mucalculus \wrt \muLK. To do so, we go back 
to the earlier proofs of completeness, and try to understand where constructiveness is lost, to better solve this problem.
%\paragraph{Analyzing earlier proofs of completeness}

 Earlier proofs of completeness for the \mucalculus rely schematically on the following idea. Find a subset $\C{C}_2$
of the set of \mucalculus formulas $\C{C}_1$ such that:
\begin{enumerate}
\item[1)]  For every valid formula $\phi_1$ in $\C{C}_1$, there is a valid formula $\phi_2$ in $\C{C}_2$ such that $\phi_2\vdash\phi_1$ is provable. 
\item[2)] Every valid formula of $\C{C}_2$ is provable.  This is the completeness result restricted to $\C{C}_2$.
\end{enumerate}
Completeness is proved by combining 1) and 2) via a cut rule:
\begin{center}
\scalebox{.9}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=.8cm, semithick]
    \node at (0,0) {$\begin{prooftree}
\Hypo{2)}
\Infer{1}[]{\vdash \phi_2}
\Hypo{1)}
\Infer{1}[]{\phi_2 \vdash \phi_1}
\Infer{2}[\rcut]{\vdash \phi_1}
\end{prooftree}
$  };
   \node[circle,fill=black!10] (S)  at (4,0) {\scriptsize $\quad\qquad\qquad\qquad\qquad\qquad\C{C}_1$};
  \node[circle,fill=black!30] (S)  at (4,0) {\scriptsize $\qquad\C{C}_2\qquad$};
  
    \end{tikzpicture}
}
\end{center}
The complexity of problems 1) and 2) depends on the class $\C{C}_2$: the larger it is, the more difficult problem 2) becomes, since it gets close to the original completeness problem. On the contrary, when $\C{C}_2$ gets smaller, the problem 1) becomes difficult. 
Kaivola's proofs  uses the class of \textit{banan form formulas}; and Walukiewicz' one uses the class of \textit{disjunctive formulas} negations. These classes are very small and problem 2) is easy to prove, but problem 1) is much more involved, and this is  where constructiveness is lost in both proofs.   
       
%\paragraph{Our solution}
Instead of splitting the difficulty in two by introducing one intermediate
class, we introduce several classes $\C{C}_n\subseteq\dots\subseteq\C{C}_1$ and generalize the proof
scheme used earlier:
\begin{enumerate}
\item[1)] For all $i\in[1,n[$ and for every valid formula $\phi_i\in\C{C}_i$,
there is a valid formula $\phi_{i+1}\in\C{C}_{i+1}$ such that $\phi_{i+1}\vdash_{\muLK}\phi_i$.
\item[2)] Every valid formula of $\C{C}_n$ is provable.
\end{enumerate}
As before, we combine these results to get completeness. The interest of this approach is to split the difficult problem of completeness into several easier problems, for which we can hope to construct effectively a proof.
\begin{center}
\scalebox{.9}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=.8cm, semithick]
    \node at (-1,0) {$\begin{prooftree}
\Hypo{\vdash \phi_n \quad \phi_n\vdash \phi_{n-1} \ \ \dots\ \ \phi_2\vdash \phi_1}
\Infer{1}[\rcut]{\vdash \phi_1}
\end{prooftree}$};

% \node[circle,fill=black!10] (S)  at (4,0) {\scriptsize $\C{C}_0\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad$};
 \node[circle,fill=black!10] (S)  at (4,0) {\scriptsize $\quad\quad\quad\quad\quad\qquad\qquad\qquad\quad\C{C}_1$};
 \node[circle,fill=black!20] (S)  at (4,0) {\scriptsize $\quad\quad\quad\quad\qquad\qquad\C{C}_2$};
 \node[circle,fill=black!30] (S)  at (4,0) {\scriptsize $\quad\quad\qquad\dots$};
 \node[circle,fill=black!40] (S)  at (4,0) {\scriptsize $\C{C}_n$};
  
    \end{tikzpicture}
}
\end{center}
Now the question is how to find these classes. For that, we identified three 
sources of complexity that make a valid formula hard to prove:
i) The alternation of disjunctions and conjunctions, ii) The interleaving of least and greatest fixed points, iii) The presence of disjunctions. In automata theory, these sources of complexity also exist with different names: i) Alternation (of universal and existential non-determinism), ii) The use of parity conditions, and iii) Non-determinism. In automata over infinite words, all these difficulties can be reduced through effective algorithms, transforming automata with one of these difficulties into others without. For example, one has algorithms to eliminate alternation, to reduce the number of priorities for a parity condition or to get rid of non-determinism. The correspondence between linear-time \mucalculus formulas and alternating parity word automata (APW) over infinite words is now very well established. This is fortunate since our idea was to import these techniques from the automata side to the logical one. Concretely, it is known that we can encode every APW $\C{A}$ by a formula $[\C{A}]$ such that the language of $\C{A}$ equals the set of models of $[\C{A}]$. The intermediate classes we will use are the following: The largest class, denoted [APW], is the image of APW  by this encoding; this class embodies all the difficulties indicated above. The next class is [NPW], the image of non-deterministic parity automata (NPW) by this encoding. 
The formulas of this class do not contain the first level of complexity which is the alternation $\vee,\wedge$. The third class is [NBW], the encoding of non-deterministic Büchi automata (NBW). Büchi automata are particular cases of parity automata where only the two priorities 0 and 1 are allowed. We can say then
 that  in this class we simplified the two difficulties i) and ii). The smallest
class  is [DBW], the image of deterministic Büchi automata, where the three difficulties are eliminated. The proof will be carried out in the following 5 steps:%, described in Figure~\ref{fig:stepsProof}.
%\begin{figure*}
\begin{center}
\begin{tabular}{|l|c|}
\hline
I & $\forall\phi\in\C{C}_0,\exists \C{A}\in\text{APW}$ such that: \\
& $\C{L}(\C{A})=\C{M}(\phi)$ and $[\C{A}]\vdash_{\muLK}\phi$.\\\hline
II & $\forall\C{A}\in\text{APW},\exists\C{P}\in\text{NPW}$ such that:\\
& $\C{L}(\C{P})=\C{L}(\C{A})$ and $[\C{P}]\vdash_{\muLK}[\C{A}]$.\\\hline
III &  $\forall\C{P}\in\text{NPW},\exists\C{B}\in\text{NBW}$ such that:\\
& $\C{L}(\C{B})=\C{L}(\C{P})$ and $[\C{B}]\vdash_{\muLK}[\C{P}]$.\\\hline
IV &  $\forall\C{B}\in\text{NBW}$, if $\C{L}(\C{B})=\Sigma^\omega$ then $\exists\C{D}\in\text{DBW}$ \st:\\
& $\C{L}(\C{D})=\Sigma^\omega$ and $[\C{D}]\vdash_{\muLK}[\C{B}]$.\\\hline
V & $\forall \C{D}\in\text{DBW}$, if $\C{L}(\C{D})=\Sigma^\omega$ then $\vdash_{\muLK}[\C{D}]$.\\\hline
\end{tabular}
\end{center}
%\caption{Road map for the completeness proof}
%\label{fig:stepsProof}
%\end{figure*}
Step IV is a bit special because in general NBW cannot be determinized into 
DBW. But if a NBW $\C{B}$ recognizes the universal language $\Sigma^\omega$, there is obviously
a DBW $\C{D}$  with the same language: the complete 
Büchi automaton with exactly one (accepting) state for instance. 
This is enough for our needs, since we start in the proof of completeness from a valid formula $\phi$ (\ie $\C{M}(\phi)=\Sigma^\omega$), hence the automata $\C{A}, \C{P}$ and $\C{B}$ constructed in steps I-III  all recognize the language
$\Sigma^\omega$.
To show that $[\C{D}]\vdash_{\muLK}[\C{B}]$ in step IV, we use a more general result from \cite{doumane16lics}, which shows
that for every Büchi automata $\C{B}_1,\C{B}_2$ such that $\C{L}(\C{B}_2)\subseteq\C{L}(\C{B}_1)$ one has $[\C{B}_2]\vdash_{\muLK}[\C{B}_1]$.
%The proof of this result relies on determinization of NBW into deterministic parity automata, but  contrarily to steps I-III where automata transformations are used to build an automaton, determinization is used in \cite{doumane16lics} as a proof-search algorithm. 

We now give an idea of how to prove the sequents of the other steps. Actually, what makes  the proof search difficult in \muLK, is the rule $\rnu$
shown below, where $S$ should be guessed.
\begin{center}
\scalebox{.95}{
$
\begin{prooftree}
\Hypo{\Gamma \vdash \Delta, S}
\Hypo{S\vdash F[S/X]}
\Infer{2}[\rnu]{\Gamma \vdash \Delta, \nu X.F}
\end{prooftree}
$}
\end{center}
To circumvent this problem, we go through an intermediate proof system where the rule $\rnu$ just unfolds the $\nu$-formula:
\begin{center}
\scalebox{.95}{
$
\begin{prooftree}
\Hypo{\Gamma\vdash \Delta, F[\nu X.F/X]}
\Infer{1}[\rnu]{\Gamma\vdash\Delta,\nu X.F}
\end{prooftree}
$}
\end{center}
Two examples of such proof systems are the one introduced in \cite{dhl06} which we call \muLKh, and the one introduced in \cite{doumane16lics}, called \muLKo. The proofs of  \muLKo and \muLKh, which have the shape of graphs,
are called \emph{circular} proofs.
The idea is to find a circular proof for the sequent to prove, 
then to transform this circular proof into a \muLK one.
%
The advantage of \muLKh is that it is competely invertible and the proof search
is a trivial task. However, the algorithms known to transform effectively \muLKh proofs into \muLK ones are very restrictive.
%
In contrast, we have given a strong translation result for \muLKo (\cite{doumane16lics}), based on a
general geometric condition on proofs. Building on this, we shall work with \muLKo. To get this stronger translatability criterion,  \muLKo uses sequents of a particular shape. Indeed, sequents are not
sets of formulas, as it is the case for \muLKh; but are rather sets of \emph{formula occurrences}.  The difficulty of using such sequents is that the proof system is not invertible and proving the sequents of steps I-V in \muLKo  is not immediate.
%The proofs of \muLKo are infinite, but finitely representable by graphs with back-edges.%; that is why we call them \emph{circular} proofs.
%To guarantee soundness, \muLKo is equipped with a validity condition saying, roughly speaking, that for a derivation to be valid, every infinite branch should be supported by the unfolding of a $\mu$-formula on the left or a $\nu$-formula on the right.  
%This proof system is very close to %tableau systems \cite{}, and  the one introduced by Dax et al. in \cite{dhl06}, that we call \muLKh.
%The algorithms known to transform effectively \muLKh proofs into \muLK ones (\cite{}) impose syntactic conditions on the conclusion formulas, which are not 
%satisfied  by the sequents we aim to prove.  Rather, in \cite{doumane16lics} a
%stronger geometric condition on \muLKo proofs is given, that ensures their translatibility into \muLK ones. 
%Thus, instead of searching for proofs of our sequents directly in \muLK, we will build proofs of the same sequents in \muLKo, satisfying the translatibility criterion from \cite{doumane16lics}.  
%To get this stronger translatability criterion,  \muLKo uses sequents of a particular shape. Indeed, sequents are not
%sets of formulas, as it is the case for \muLKh; but are rather sets of \emph{formula occurrences}. This means that in a sequent, one distinguishes between two different occurrences of a given formula by assigning them two different addresses.
%Concretely, given a set of addresses $A$, a sequent is a set of pairs $(\phi,a)$, written as $\phi_a$, where $\phi$ is a formula and $a\in A$. The details of how the addresses are updated after rule applications are given in the core of the paper.
%The difficulty of using such sequents is that the proof system is not invertible, contrarily to \muLKh.
%and the proof search is not a trivial task.
%For instance, let $\phi=\mu X.\nu Y. X\vee Y$
%and  $\psi=\nu Y. \phi\vee Y$ its unfolding. The \muLKh proof $\pi$ of 
%$\phi\vee\psi$,  shown below, is obtained by applying bottom up all the possible logical rules. But if we apply the same rules in \muLKo, we get the proof $\theta$ below, which is not circular since the size of its sequents is unbound:
%\vspace{-2.4mm}
%\begin{center}
%\scalebox{.95}{
%$
%\pi=\quad
%\begin{prooftree}
%\Hypo{(\star)}
%\Infer{1}[]{\vdash \phi\vee\psi}
%\Infer[rulestyle=double]{1}[]{\vdash \phi,\psi}
%\Infer{1}[]{\vdash \phi\vee\psi\ \ (\star)}
%\end{prooftree}
%\qquad
%\quad
%\theta=\quad
%\begin{prooftree}
%\Hypo{\vdots}
%\Infer{1}[]{\vdash (\phi\vee\psi)_d, (\phi\vee\psi)_e}
%\Infer[rulestyle=double]{1}[]{\vdash \phi_b,\psi_c}
%\Infer{1}[]{\vdash (\phi\vee\psi)_a}
%\end{prooftree}
%$}
%\end{center}
%To get a  circular proof, we have to apply some weakening. But the choice of which formula to weaken is crucial, since a bad choice may lead to a non valid 
%proof. For instance, if we weaken the formula $\psi_c$, the obtained derivation, $\theta_1$ below, is circular but does not satisfy the validity condition, since its infinite branch unfolds infinitely often a $\mu$-formula on the right. The good choice of weakening is the one that weakens $\phi_b$, yeilding the proof $\theta_2$ below:
%\begin{center}
%\scalebox{.95}{
%$
%\theta_1=\quad
%\begin{prooftree}
%\Hypo{(\star)}
%\Infer{1}[]{\vdash (\phi\vee\psi)_d}
%\Infer[rulestyle=double]{1}{\vdash \phi_b}
%\Infer{1}[]{\vdash \phi_b,\psi_c}
%\Infer{1}[]{\vdash (\phi\vee\psi)_a\ (\star)}
%\end{prooftree}
%\qquad
%\quad
%\theta_2=\quad
%\begin{prooftree}
%\Hypo{(\star)}
%\Infer{1}[]{\vdash (\phi\vee\psi)_e}
%\Infer[rulestyle=double]{1}{\vdash \psi_c}
%\Infer{1}[]{\vdash \phi_b,\psi_c}
%\Infer{1}[]{\vdash (\phi\vee\psi)_a\ (\star)}
%\end{prooftree}
%$}
%\end{center}
%and proving the sequents of steps I-V in \muLKo  is not a trivial task as it would be in \muLKh.
%, since we have to do some clever choices to get at 
%the same time derivations  which are circular, that satisfy the validity condition and the translatability criterion.   

Let us finally emphasize that the implications appearing in steps I-V are well known at the semantical level, but lifting them to the provability level is not immediate and strongly depends on the encoding $[\_]$ and the shape of automata obtained by
the different automata transformations.  To illustrate this by an extremal example, any valid formula $\phi$ is semantically equivalent to $\top$ and to itself, but proving  $\top\vdash\phi$ is as difficult as proving $\vdash\phi$, while proving $\phi\vdash\phi$ is immediate. In general, given a formula $\psi$ semantically equivalent to $\phi$, closer
   $\psi$ is to $\phi$, the easier $\psi\vdash\phi$
will be to prove. That is why we will provide for our development an encoding 
of automata that follows closely their structure; and automata transformations that do not change brutally the input automaton (or the input formula for step I). That is also why we cannot treat these transformations as black 
boxes and will recall them in detail.
% in the core of the paper.   

\textit{Organization of the paper} In Section~\ref{Mucalculus} we introduce the linear-time \mucalculus and its semantics together with %the proof systems
\muLK and \muLKo. Then we state a sufficient condition
%, weaker than the one in \cite{doumane16lics},
that ensures the translatability of \muLKo proofs into \muLK ones. 
%
In Section~\ref{AutomataMucalculus}, we present the model of APW  and their encoding $[\_]$ in the linear-time \mucalculus. Conversely, we give a way to build for every \mucalculus formula $\phi$ an APW $\C{A}_\phi$ that recognizes the set of its models. The main result of this section is $[\C{A}_\phi]\vdash_{\muLK}\phi$.
%
In Section~\ref{AutomataEquiv}, we recall the automata transformations that turn an APW $\C{A}$ into an NPW $\C{P}$, and $\C{P}$ into an NBW $\C{B}$, all having the same language. The main results of this section are $[\C{B}]\vdash_{\muLK}[\C{P}]$ and  $[\C{P}]\vdash_{\muLK}[\C{A}]$.
%
In Section~\ref{PickUpPieces}, we show that for every NBW $\C{B}$ recognizing the language $\Sigma^\omega$, there is a
 DBW $\C{D}$ recrognizing also $\Sigma^\omega$, such that $[\C{D}]\vdash_{\muLK}[\C{B}]$ and $\vdash_{\muLK}[\C{D}]$. We finally bring these pieces together to get a constructive proof of completeness.   

\beginshort
This paper is supported by a long version available at~\cite{TechReport}.
\endshort
